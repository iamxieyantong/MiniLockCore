//
//  StreamDecryptor.swift
//  MiniLockCore
//
//  Created by Mohak Shah on 23/03/17.
//

import Foundation
import libsodium
import libb2s

extension MiniLock
{
    public final class StreamDecryptor: StreamCryptoBase
    {
        private let cipherPadding = [UInt8](repeating: 0, count: CryptoSecretBoxSizes.CipherTextPadding)
        private var messageBuffer =  [UInt8](repeating: 0, count: CryptoSecretBoxSizes.MessagePadding + MiniLock.FileFormat.PlainTextBlockMaxBytes)

        /// Decrypts the given block with the key and nonce that the object was initialized with
        ///
        /// - Parameters:
        ///   - block: encrypted block generated by MiniLock.StreamEncryptor.encrypt()
        ///   - isLastBlock: set to true if this is the last blcok
        /// - Returns: the decrypted plain text
        /// - Throws: StreamCryptoBase.CryptoError
        public func decrypt(cipherBlock: Data, isLastBlock: Bool) throws -> Data {
            // perform sanity checks
            if processStatus != .incomplete {
                throw CryptoError.processComplete
            }

            guard cipherBlock.count > (CryptoSecretBoxSizes.MAC + MiniLock.FileFormat.BlockSizeTagLength),
                cipherBlock.count <= (MiniLock.FileFormat.BlockSizeTagLength + MiniLock.FileFormat.PlainTextBlockMaxBytes + CryptoSecretBoxSizes.MAC) else {
                    throw CryptoError.inputSizeInvalid
            }

            // extract plain text message size and validate size of block against it
            var messageSize = 0
            for i in 0..<MiniLock.FileFormat.BlockSizeTagLength {
                messageSize |= Int(cipherBlock[i]) << (8 * i)
            }

            guard (messageSize + MiniLock.FileFormat.BlockSizeTagLength + CryptoSecretBoxSizes.MAC) == cipherBlock.count else {
                throw CryptoError.inputSizeInvalid
            }

            // calculate the hash of cipherblock
            cipherBlock.withUnsafeBytes { (cipherBlockPointer) -> Void in
                blake2s_update(blake2SStatePointer, cipherBlockPointer, cipherBlock.count)
            }
            

            if isLastBlock {
                // set MSB of the block counter
                fullNonce[fullNonce.count - 1] |= 0x80

                _processStatus = .succeeded

                // finalise blake2s and save the result
                blake2s_final(blake2SStatePointer, UnsafeMutablePointer(mutating: _cipherTextHash), StreamCryptoBase.Blake2sOutputLength)
            }

            // attempt to decrypt cipher text
            
            // note: padding using "append" function instead of '+' operator vastly improves the performance
            var paddedCipherBlock = Data(cipherPadding)
            paddedCipherBlock.append(cipherBlock[MiniLock.FileFormat.BlockSizeTagLength..<cipherBlock.count])

            let returnValue = paddedCipherBlock.withUnsafeBytes { (cipherBlockPointer: UnsafePointer<UInt8>) -> Int32 in
              return crypto_secretbox_open(UnsafeMutablePointer(mutating: messageBuffer),
                                             cipherBlockPointer,
                                             UInt64(paddedCipherBlock.count),
                                             fullNonce,
                                             key)
            }
            

            incrementNonce()

            // decryption failed
            if returnValue != 0 {
                _processStatus = .failed

                if returnValue == -1 {
                    throw CryptoError.macVerificationFailed
                } else {
                    throw CryptoError.decryptionFailed
                }
            }

            // decryption succeeded!
            return Data(bytesNoCopy: UnsafeMutablePointer(mutating: messageBuffer).advanced(by: CryptoSecretBoxSizes.MessagePadding),
                        count: messageSize,
                        deallocator: .none)
        }
    }
}
