//
//  StreamDecryptor.swift
//  MiniLockCore
//
//  Created by Mohak Shah on 23/03/17.
//

import Foundation
import libsodium
import libb2s

extension MiniLock
{
    public class StreamDecryptor: StreamCryptoBase
    {

        /// Decrypts the given block with the key and nonce that the object was initialized with
        ///
        ///
        /// - Parameters:
        ///   - block: enciphered block generated by MiniLockStreamEncryptor.encrypt()
        ///   - isLastBlock: set to true if this is the last blcok
        /// - Returns: the decrypted plain text
        /// - Throws: MiniLockStreamCryptor.CryptoError
        func decrypt(block: [UInt8], isLastBlock: Bool) throws -> [UInt8] {
            if processStatus != .incomplete {
                throw CryptoError.processComplete
            }

            guard block.count > (CryptoBoxSizes.MAC + MiniLock.FileFormat.BlockSizeTagLength),
                block.count <= (MiniLock.FileFormat.BlockSizeTagLength + MiniLock.FileFormat.PlainTextBlockMaxBytes + CryptoBoxSizes.MAC) else {
                    throw CryptoError.inputSizeInvalid
            }

            // extract plain text message size and validate size of block against it
            var messageSize = 0
            for i in 0..<MiniLock.FileFormat.BlockSizeTagLength {
                messageSize |= Int(block[i]) << (8 * i)
            }

            guard (messageSize + MiniLock.FileFormat.BlockSizeTagLength + CryptoBoxSizes.MAC) == block.count else {
                throw CryptoError.inputSizeInvalid
            }

            // calculate the hash of cipherblock
            _ = withUnsafeMutablePointer(to: &blake2SState) { (statePointer) in
                blake2s_update(statePointer, block, block.count)
            }

            if isLastBlock {
                // set MSB of the block counter
                fullNonce[fullNonce.count - 1] |= 0x80

                _processStatus = .succeeded

                // finalise blake2s and save the result
                _ = withUnsafeMutablePointer(to: &blake2SState) { (statePointer) in
                    blake2s_final(statePointer, UnsafeMutablePointer(mutating: _cipherTextHash), StreamCryptoBase.Blake2sOutputLength)
                }
            }

            cipherBuffer.overwrite(with: block[MiniLock.FileFormat.BlockSizeTagLength..<block.count], atIndex: CryptoBoxSizes.CipherTextPadding)

            let returnValue = crypto_secretbox_open(UnsafeMutablePointer(mutating: messageBuffer),
                                  cipherBuffer,
                                  UInt64(block.count),
                                  fullNonce,
                                  key)

            incrementNonce()

            if returnValue != 0 {
                _processStatus = .failed

                if returnValue == -1 {
                    throw CryptoError.macVerificationFailed
                } else {
                    throw CryptoError.decryptionFailed
                }
            }

            return Array(messageBuffer[CryptoBoxSizes.MessagePadding..<(CryptoBoxSizes.MessagePadding + messageSize)])
        }
    }
}
